
#include "Scene_Menu.hpp"

Scene_Menu::Scene_Menu(SceneHandler* sceneHandler, Resources* resources, sf::RenderWindow* window) : Scene(sceneHandler, resources), window(window) {}

Scene_Menu::~Scene_Menu() {}

void Scene_Menu::init()
{
    menuText.setFont(_resources->Font("font"));
    menuText.setCharacterSize(24.f);
    menuText.setFillColor(sf::Color(255, 102, 0));
    menuText.setString("MENU");
    menuText.setPosition(704, 15);

    menuRect.setSize(sf::Vector2f(110.f, 170.f));
    menuRect.setFillColor(sf::Color(0, 204, 153));
    menuRect.setPosition(680, 10);

    typeNum = 0;

    typeText.setFont(_resources->Font("font"));
    typeText.setCharacterSize(20.f);
    typeText.setFillColor(sf::Color::Black);
    typeText.setString("Type:");
    typeText.setPosition(690, 50);

    typeValue.setFont(_resources->Font("font"));
    typeValue.setCharacterSize(20.f);
    typeValue.setFillColor(sf::Color::Blue);
    typeValue.setString(typeStrings[typeNum]);
    typeValue.setPosition(745, 50);

    valNum = 0;

    valText.setFont(_resources->Font("font"));
    valText.setCharacterSize(20.f);
    valText.setFillColor(sf::Color::Black);
    valText.setString("Nod:");
    valText.setPosition(690, 80);

    valValue.setFont(_resources->Font("font"));
    valValue.setCharacterSize(20.f);
    valValue.setFillColor(sf::Color::Blue);
    valValue.setString(std::to_string(valNum));
    valValue.setPosition(745, 80);

    onWrite = false;

    distNum = 0;

    distText.setFont(_resources->Font("font"));
    distText.setCharacterSize(20.f);
    distText.setFillColor(sf::Color::Black);
    distText.setString("Dist:");
    distText.setPosition(690, 110);

    distValue.setFont(_resources->Font("font"));
    distValue.setCharacterSize(20.f);
    distValue.setFillColor(sf::Color::Blue);
    distValue.setString(distStrings[distNum]);
    distValue.setPosition(745, 110);

    genText.setFont(_resources->Font("font"));
    genText.setCharacterSize(30.f);
    genText.setFillColor(sf::Color(255, 0, 102));
    genText.setString("GEN");
    genText.setPosition(705, 140);
    genText.setOutlineThickness(1.f);
    genText.setOutlineColor(sf::Color::Black);

    view = sf::Vector2f(0, 0);
    zoom = 1.f;
}

void Scene_Menu::handleEvents(const sf::Event& event)
{
    switch(event.type)
    {
        case sf::Event::MouseButtonPressed:
        {
            switch(event.key.code)
            {
                case sf::Mouse::Left:
                {
                    if(genText.getGlobalBounds().contains(sf::Vector2f(sf::Mouse::getPosition(*window))))
                    {
                        if(valNum != 0)
                        {
                            generate(valNum);
                            distribute(distNum);
                        }
                        onWrite = false;
                    }
                    else if(typeValue.getGlobalBounds().contains(sf::Vector2f(sf::Mouse::getPosition(*window))))
                    {
                        typeNum++;
                        typeNum%=2;
                        typeValue.setString(typeStrings[typeNum]);
                    }
                    else if(valValue.getGlobalBounds().contains(sf::Vector2f(sf::Mouse::getPosition(*window))))
                    {
                        onWrite = true;
                        valNum = 0;
                        valValue.setString("_");
                    }
                    else if(distValue.getGlobalBounds().contains(sf::Vector2f(sf::Mouse::getPosition(*window))))
                    {
                        distNum++;
                        distNum%=4;
                        distValue.setString(distStrings[distNum]);
                    }

                    for(unsigned int i = 0; i < nodes.size(); ++i)
                    {
                        if(distance(sf::Vector2f(sf::Mouse::getPosition(*window)), (nodes[i].pos + view) * zoom) <= 20.f * zoom) currNode = &nodes[i];
                    }
                }
                default:
                    break;
            }
        }
            break;
        case sf::Event::MouseButtonReleased:
        {
            switch(event.key.code)
            {
                case sf::Mouse::Left:
                {
                    currNode = nullptr;
                }
                default:
                    break;
            }
        }
            break;
        
        case sf::Event::KeyPressed:
        {
            if(onWrite)
            {
                switch(event.key.code)
                {
                    default:
                    {
                        if(event.key.code >= sf::Keyboard::Num0 && event.key.code <= sf::Keyboard::Num9)
                        {
                            valNum *= 10;
                            valNum += event.key.code - sf::Keyboard::Num0;
                        }
                    }
                        break;
                }
            }
            else
            {
                switch(event.key.code)
                {
                    case sf::Keyboard::Up:
                    {
                        if(sf::Keyboard::isKeyPressed(sf::Keyboard::LShift) && zoom < 5) zoom += 0.1f;
                        else view = view + sf::Vector2f(0.f, 20.f);
                    }
                        break;
                    case sf::Keyboard::Down:
                    {
                        if(sf::Keyboard::isKeyPressed(sf::Keyboard::LShift) && zoom > 0.1) zoom -= 0.1f;
                        else view = view + sf::Vector2f(0.f, -20.f);
                    }
                        break;
                    case sf::Keyboard::Left:
                    {
                        view = view + sf::Vector2f(20.f, 0.f);
                    }
                        break;
                    case sf::Keyboard::Right:
                    {
                        view = view + sf::Vector2f(-20.f, 0.f);
                    }
                        break;
                    default:
                        break;
                }
            }
        }
            break;
        default:
            break;
    }
}

void Scene_Menu::update(const sf::Time deltatime)
{
    if(currNode != nullptr)
    {
        currNode->pos = (sf::Vector2f(sf::Mouse::getPosition(*window)) /zoom) - view;
    }

    if(onWrite && valNum > 0)
    {
        valValue.setString(to_string(valNum));
    }
}

void Scene_Menu::draw(sf::RenderWindow& window) const
{
    sf::Text key;
    sf::CircleShape node;
    sf::Vertex line[2];

    key.setFont(_resources->Font("font"));
    key.setCharacterSize(18.f * zoom);
    key.setFillColor(sf::Color::White);
    key.setString("-");

    node.setRadius(20.f * zoom);
    node.setOrigin(20.f * zoom, 20.f * zoom);
    node.setFillColor(sf::Color::Red);

    line[0] = sf::Vertex(sf::Vector2f(0, 0));
    line[1] = sf::Vertex(sf::Vector2f(0, 0));

    for(unsigned int i = 0; i < nodes.size(); ++i)
    {
        line[0] = (nodes[i].pos + view) * zoom;

        for(unsigned int j = 0; j < nodes[i].con.size(); ++j)
        {
            line[1] = (nodes[nodes[i].con[j]].pos + view) * zoom;
            window.draw(line, 2, sf::Lines);
        }  
    }

    for(unsigned int i = 0; i < nodes.size(); ++i)
    {
        key.setString(std::to_string(i));
        key.setPosition((nodes[i].pos - sf::Vector2f(10.f, 10.f) + view) * zoom);

        node.setPosition((nodes[i].pos + view) * zoom);

        window.draw(node);
        window.draw(key);
    }

    window.draw(menuRect);
    window.draw(menuText);
    window.draw(genText);
    window.draw(typeText);
    window.draw(typeValue);
    window.draw(valText);
    window.draw(valValue);
    window.draw(distText);
    window.draw(distValue);
}

void Scene_Menu::pause() {}

void Scene_Menu::resume() {}

float Scene_Menu::distance(sf::Vector2f p1, sf::Vector2f p2)
{
    float dX = p1.x - p2.x;
    float dY = p1.y - p2.y;

    float d = sqrt(dX*dX + dY*dY);

    return d;
}

void Scene_Menu::generate(int n)
{
    currNode = nullptr;
    nodes = std::vector<node>(n);

    Graph graph;

    if(typeNum == 0) generateRandomUndirectedTree(n, graph);
    else if(typeNum == 1) generateRandomUndirectedGraph(n, 0.5, graph);

    for(unsigned int i = 0; i < graph.size(); ++i)
    {
        nodes[i].con = std::vector<int>(graph[i].size());

        int j = 0;
        std::list<int>::const_iterator it = graph[i].begin();
        while(it != graph[i].end())
        {
            nodes[i].con[j] = *it;
            ++j;
            ++it;
        }
    }
}

void Scene_Menu::distribute(int mode)
{
    if(mode == 0)
    {
        map<int, list<int>> levels;
        vector<bool> vis(nodes.size(), false);

        //BFS

        queue<pair<int,int>> q;
        q.push(make_pair(0, 0));

        while(!q.empty())
        {
            pair<int,int> c = q.front();
            q.pop();

            vis[c.first] = true;

            for(unsigned int i = 0; i < nodes[c.first].con.size(); ++i)
            {
                if(!vis[nodes[c.first].con[i]])
                {
                    q.push(make_pair(nodes[c.first].con[i], c.second+1));
                }
            }

            levels[c.second].insert(levels[c.second].end(), c.first);
        }

        int y = 100;

        for(unsigned int i = 0; i < levels.size(); ++i)
        {
            int sep = 800/levels[i].size();

            int x = 0;

            list<int>::const_iterator it = levels[i].begin();
            while(it != levels[i].end())
            {
                nodes[*it].pos = sf::Vector2f(sep/2 + x*sep, y);
                ++x;
                ++it;
            }

            y += 100;
        }
    }
    else if(mode == 1 || mode == 2)
    {
        int max = 0;

        if(mode == 2)
        {
            for(unsigned int i = 0; i < nodes.size(); ++i)
            {
                if(nodes[i].con.size() > nodes[max].con.size()) max = i;
            }
        }

        vector<bool> vis(nodes.size(), false);
        nodes[max].pos = sf::Vector2f(400, 400);
        vis[max] = true;
        roundDistribute(sf::Vector2f(400, 400), vis, 0, 2*PI, 1, max);
    }
    else if(mode == 3)
    {
        for(unsigned int i = 0; i < nodes.size(); ++i)
        {
            nodes[i].pos = sf::Vector2f(100 + 100*(i%6), 100 + 100*(i/6));
        }
    }
}

void Scene_Menu::roundDistribute(sf::Vector2f c, vector<bool>& v, float aI, float aF, int o, int n)
{
    float aN;
    if(o == 1) aN = (aF-aI)/(nodes[n].con.size());
    else aN = (aF-aI)/(nodes[n].con.size()-1);

    int j = 0;

    for(unsigned int i = 0; i < nodes[n].con.size(); ++i)
    {
        if(!v[nodes[n].con[i]])
        {
            float aCI = aI + aN*j;
            float aCF = aI + aN*(j+1);
            float aC = (aCI+aCF)/2;

            sf::Vector2f vC = sf::Vector2f(cos(aC), sin(aC));
            vC = vC / (sqrt(vC.x*vC.x + vC.y*vC.y));

            nodes[nodes[n].con[i]].pos = c + (vC * float(o) * 100.f);
            v[nodes[n].con[i]] = true;

            ++j;

            roundDistribute(c, v, aCI, aCF, o+1, nodes[n].con[i]);
        }
    }
}


